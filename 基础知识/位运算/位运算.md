# 异或

相同为0，相异为一。相当于二进制无进位相加。

### 性质

```
0 ^ N = N	N ^ N = 0
交换律：a ^ b = b ^ a
结合律：(a ^ b)^ c = a ^(b ^ c)
一堆数据异或，与异或顺序无关：a ^ b ^ c ^ d ... ^ m   
```

### 实现案例

##### 在不同内存空间的两数交换

```
func swap(a,b int){
	a = a ^ b
	b = a ^ b
	a = a ^ b
}
```

```
分析：
设a实际数据为m，b实际数据为n
a = a ^ b ------> a = m ^ n
b = a ^ b ------> b = (m ^ n)^ n = m ^ (n ^ n) = m
a = a ^ b ------> a = (m ^ n)^ m = (m ^ m)^ n = n
```

##### 求一个数二进制时最右边的1

```
eor = (^a + 1) & a
```

```
分析：（在go中，取反符号不是 ~ 而是 ^ ,与异或符号一致）
取反加一，保留最右边的1，和其后面的0，其他位置取反
与，除去最右边的1，其余地方都归0
举例：
a = 0100 0010
eor = (1011 1101 + 1) & (0100 0010)
    = 1011 1110 & 0100 0010
    = 0000 0010
```

##### 数组中，一个数出现了奇数次，其他数出现了偶数次，要找奇数次的数

```
func question1(arr []int) {
	var result int
	for i := 0; i < 11; i++ {
		result = result ^ arr[i]
	}
	fmt.Println(result)
}
```

```
分析：
N ^ N = 0 可知，出现偶数次的数最后会变成0，出现奇数次的数会剩下一个
0 ^ N = N 可知，剩下的数会保持原值
```

##### 数组中，2个数出现了奇数次，其他数出现了偶数次，要找奇数次的数

```
func question2(arr []int) {
	var result, a, b int
	for i := 0; i < 12; i++ {
		result ^= arr[i]
	}
	eor := result & (^result + 1)
	for i := 0; i < 12; i++ {
		if (arr[i] & eor) == eor {
			a ^= arr[i]
		}
	}
	b = result ^ a
	fmt.Println(a, b)
}
```

```
分析：
result = m ^ n
因为 m,n 不是同一个数，所以 result 不为0
eor提取出result最右侧的1，在此位置上，m和n只有一个表现出1（假设为m）
a = m
b = m ^ n ^ m = n
```

# 左移和右移

左移运算符 << 和右移运算符 >>是双目运算符。左移n位就是乘以2的n次方，右移n位就是除以2的n次方。
